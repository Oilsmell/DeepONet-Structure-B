# -*- coding: utf-8 -*-
"""
[Step 2] Verify Model on Structure A (Internal Validation)
- Load the pre-trained model on Structure A.
- Generate damage signals and compare them with the real Ground Truth signals.
- Visualization of waveform matching performance.
"""

import numpy as np
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
import os
from scipy.stats import kurtosis
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import mean_squared_error

# =========================================================
# 0. ì„¤ì • (Configuration)
# =========================================================
DATA_PATH = r"E:\Benchmark Code\benchmarktu1402-master\f_accerlerations\ds1"
MODEL_PATH = r"E:\2ndstructuredata\Code\deeponet_phase2_structure_A.pth"

SELECTED_NODE_INDICES = [3, 21, 39, 57, 63, 81, 99, 117]
FS = 1000.0
WINDOW_SIZE = 128
TRAIN_POINTS = 128000
VAL_POINTS = 64000

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"ğŸš€ Current Device: {device}")

# =========================================================
# 1. ëª¨ë¸ ì •ì˜ (í•™ìŠµ ì‹œì™€ ë™ì¼)
# =========================================================
class FourierFeature(nn.Module):
    def __init__(self, input_dim, mapping_size=256, scale=15):
        super().__init__()
        self.register_buffer('B', torch.randn(input_dim, mapping_size) * scale)

    def forward(self, x):
        projected = 2 * np.pi * (x @ self.B)
        return torch.cat([torch.sin(projected), torch.cos(projected)], dim=-1)

class DeepONetPhase2(nn.Module):
    def __init__(self, branch_dim, trunk_dim, hidden_dim=256, output_dim=256):
        super().__init__()
        self.activation = nn.SiLU()
        self.branch = nn.Sequential(
            nn.Linear(branch_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, output_dim),
        )
        self.fourier_dim = 256
        self.fourier = FourierFeature(trunk_dim, mapping_size=self.fourier_dim, scale=15.0)
        self.trunk = nn.Sequential(
            nn.Linear(self.fourier_dim * 2, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, output_dim),
        )
        self.bias = nn.Parameter(torch.zeros(1))

    def forward(self, u, y):
        B = self.branch(u)
        y_embedded = self.fourier(y)
        T = self.trunk(y_embedded)
        B_expanded = B.unsqueeze(1)
        output = torch.sum(B_expanded * T, dim=-1)
        return output + self.bias

# =========================================================
# 2. ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# =========================================================
def load_specific_nodes(filepath, target_indices):
    try:
        if not os.path.exists(filepath): return None
        full_data = np.loadtxt(filepath)
        return full_data[:, target_indices].astype(np.float32)
    except: return None

def calculate_kurtosis_feature(signal, fs, window_sec=2.0):
    points = int(fs * window_sec)
    n = len(signal) // points
    if n == 0: return 0.0
    k = kurtosis(signal[:n*points].reshape(n, points), axis=1, fisher=False)
    return np.percentile(k, 95)

def prepare_data_split(raw_data, start_idx, num_points, window_size):
    data_slice = raw_data[start_idx : start_idx + num_points, :]
    num_samples = num_points // window_size
    flattened = data_slice.reshape(num_samples, window_size, -1).reshape(num_samples, -1)
    return flattened, num_samples

# =========================================================
# 3. ë©”ì¸ ê²€ì¦ í”„ë¡œì„¸ìŠ¤
# =========================================================
def main():
    # 1. ë°ì´í„° ë¡œë“œ ë° ì „ì²˜ë¦¬ (í•™ìŠµ ë°ì´í„°ì™€ ë™ì¼í•œ ìŠ¤ì¼€ì¼ëŸ¬ êµ¬ì„±ì„ ìœ„í•´ ì „ì²´ ë¡œë“œ)
    print("[1] Loading Structure A Data for Scaler Reconstruction...")
    h_file = os.path.join(DATA_PATH, "fh_accelerations.dat")
    raw_h = load_specific_nodes(h_file, SELECTED_NODE_INDICES)
    
    raw_d_list = []
    for i in range(1, 11):
        d_file = os.path.join(DATA_PATH, f"f{i}_accelerations.dat")
        raw_d_list.append(load_specific_nodes(d_file, SELECTED_NODE_INDICES))

    # DI ê³„ì‚°
    base_kurts = [calculate_kurtosis_feature(raw_h[:, s], FS) for s in range(8)]
    c_values = []
    for d_data in raw_d_list:
        diffs = [abs(base_kurts[s] - calculate_kurtosis_feature(d_data[:, s], FS)) for s in range(8)]
        c_values.append(np.mean(diffs))
    c_values = np.array(c_values).reshape(-1, 1)

    # Scaler ì¬êµ¬ì„±ì„ ìœ„í•œ í•™ìŠµ ë°ì´í„° ì¤€ë¹„ (01ë²ˆ ì½”ë“œì™€ ë™ì¼ ë¡œì§)
    u_train_raw, n_train_samples = prepare_data_split(raw_h, 0, TRAIN_POINTS, WINDOW_SIZE)
    U_train_base = np.tile(u_train_raw, (10, 1))
    di_train_list = [np.full((n_train_samples, 1), c_values[i, 0]) for i in range(10)]
    U_train_combined = np.hstack([U_train_base, np.concatenate(di_train_list, axis=0)])
    
    g_train_parts = [prepare_data_split(d, 0, TRAIN_POINTS, WINDOW_SIZE)[0] for d in raw_d_list]
    G_train_final = np.concatenate(g_train_parts, axis=0)

    scaler_u, scaler_g, scaler_y = StandardScaler(), StandardScaler(), MinMaxScaler()
    scaler_u.fit(U_train_combined)
    scaler_g.fit(G_train_final)
    
    # 2. ê²€ì¦ìš© ë°ì´í„° ì¤€ë¹„ (Validation Set)
    print("[2] Preparing Validation Samples...")
    u_val_raw, n_val_samples = prepare_data_split(raw_h, TRAIN_POINTS, VAL_POINTS, WINDOW_SIZE)
    
    # ì˜ˆì‹œë¡œ 'Case 5' (ì¤‘ê°„ ì •ë„ ì†ìƒ) ì‹œë‚˜ë¦¬ì˜¤ ì„ íƒ
    CASE_IDX = 4 # index 4 is f5
    target_di = c_values[CASE_IDX, 0]
    
    U_val_base = u_val_raw # (N_val, 1024)
    DI_val_col = np.full((n_val_samples, 1), target_di)
    U_val_combined = np.hstack([U_val_base, DI_val_col])
    U_val_scaled = scaler_u.transform(U_val_combined)
    
    # ì •ë‹µì§€ (Real Damaged Signal f5)
    g_val_real, _ = prepare_data_split(raw_d_list[CASE_IDX], TRAIN_POINTS, VAL_POINTS, WINDOW_SIZE)
    G_val_real_scaled = scaler_g.transform(g_val_real)

    # Trunk Grid ì¤€ë¹„
    t_idx, s_idx = np.arange(WINDOW_SIZE), np.arange(8)
    t_mesh, s_mesh = np.meshgrid(t_idx, s_idx, indexing='ij')
    y_grid = np.stack([t_mesh.flatten(), s_mesh.flatten()], axis=1)
    scaler_y.fit(y_grid) # TrunkëŠ” ê³ ì • ê·¸ë¦¬ë“œì´ë¯€ë¡œ ì—¬ê¸°ì„œ fit
    y_grid_scaled = scaler_y.transform(y_grid)

    # 3. ëª¨ë¸ ë¡œë“œ
    print("[3] Loading Trained Model...")
    model = DeepONetPhase2(branch_dim=1025, trunk_dim=2).to(device)
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device, weights_only=True))
    model.eval()

    # 4. ì¶”ë¡  (Inference)
    print("[4] Generating Damaged Signal...")
    sample_idx = 0 # ê²€ì¦ ì„¸íŠ¸ì˜ ì²« ë²ˆì§¸ ìœˆë„ìš° ìƒ˜í”Œ ì„ íƒ
    u_input = torch.FloatTensor(U_val_scaled[sample_idx:sample_idx+1]).to(device)
    y_input = torch.FloatTensor(y_grid_scaled).unsqueeze(0).to(device)

    with torch.no_grad():
        pred_scaled = model(u_input, y_input).cpu().numpy().reshape(1, -1)
    
    # ì—­ì •ê·œí™” (Physical Unit ë³µì›)
    pred_phys = scaler_g.inverse_transform(pred_scaled).reshape(WINDOW_SIZE, 8)
    real_phys = g_val_real[sample_idx].reshape(WINDOW_SIZE, 8)
    healthy_phys = u_val_raw[sample_idx].reshape(WINDOW_SIZE, 8)

    # 5. ì‹œê°í™” (Visualization)
    print("[5] Visualizing Internal Validation Results...")
    sensor_to_plot = 0 # 1ë²ˆ ì„¼ì„œ(Index 0) ì¶œë ¥
    
    plt.figure(figsize=(12, 6))
    plt.plot(healthy_phys[:, sensor_to_plot], 'g:', alpha=0.5, label='Healthy Input (Structure A)')
    plt.plot(real_phys[:, sensor_to_plot], 'b-', linewidth=1.5, label=f'Real Damage (f{CASE_IDX+1}, DI={target_di:.4f})')
    plt.plot(pred_phys[:, sensor_to_plot], 'r--', linewidth=2, label='Generated Damage (DeepONet)')
    
    plt.title(f"Structure A Internal Validation: Real vs Predicted\nMSE: {mean_squared_error(real_phys, pred_phys):.6f}")
    plt.xlabel("Time Step (Window)")
    plt.ylabel("Acceleration (m/sÂ²)")
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    print("âœ… Internal validation complete. Waveform comparison displayed.")

if __name__ == "__main__":
    main()
