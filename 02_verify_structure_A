# -*- coding: utf-8 -*-
"""
Created on Fri Feb  6 14:12:46 2026

@author: Oilsmell
"""

# -*- coding: utf-8 -*-
"""
[Step 2] Verify Model on Structure A (Self-Check)
Checks if the model can reproduce Structure A damage signals.
"""
import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
import os

# --- 설정 (경로 변경) ---
DATA_PATH = r"E:\Benchmark Code\benchmarktu1402-master\f_accerlerations\ds1"
MODEL_PATH = r"E:\2ndstructuredata\Code\deeponet_phase2_structure_A.pth"
SELECTED_NODE_INDICES = [3, 21, 39, 57, 63, 81, 99, 117]
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# --- 모델 클래스 복사 ---
class FourierFeature(nn.Module):
    def __init__(self, input_dim, mapping_size=256, scale=15):
        super().__init__()
        self.register_buffer('B', torch.randn(input_dim, mapping_size) * scale)
    def forward(self, x):
        projected = 2 * np.pi * (x @ self.B)
        return torch.cat([torch.sin(projected), torch.cos(projected)], dim=-1)

class DeepONetPhase2(nn.Module):
    def __init__(self, branch_dim, trunk_dim, hidden_dim=256, output_dim=256):
        super().__init__()
        self.activation = nn.SiLU()
        self.branch = nn.Sequential(
            nn.Linear(branch_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, output_dim),
        )
        self.fourier_dim = 256
        self.fourier = FourierFeature(trunk_dim, mapping_size=self.fourier_dim, scale=15.0)
        self.trunk = nn.Sequential(
            nn.Linear(self.fourier_dim * 2, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, output_dim),
        )
        self.bias = nn.Parameter(torch.zeros(1))
    def forward(self, u, y):
        B = self.branch(u)
        y_embedded = self.fourier(y)
        T = self.trunk(y_embedded)
        B_expanded = B.unsqueeze(1)
        return torch.sum(B_expanded * T, dim=-1) + self.bias

def main():
    print("[1] Loading Model...")
    if not os.path.exists(MODEL_PATH):
        print(f"❌ Model not found: {MODEL_PATH}")
        return
    model = DeepONetPhase2(branch_dim=1025, trunk_dim=2).to(device)
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device))
    model.eval()
    print("   Model loaded successfully.")
    print("   Please check training loss logs for primary verification.")

if __name__ == "__main__":
    main()
