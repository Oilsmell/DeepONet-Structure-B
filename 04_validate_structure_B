# -*- coding: utf-8 -*-
"""
Created on Fri Feb  6 14:00:26 2026

@author: Oilsmell
"""

# -*- coding: utf-8 -*-
"""
[Step 4] Validate Structure B (Real Damage vs Generated Damage)
"""
import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import os
from scipy.stats import kurtosis, pearsonr
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import mean_squared_error

# --- ÏÑ§Ï†ï ---
HEALTHY_PATH = r"E:\2ndstructuredata\raw data\healthyclean.txt"
DAMAGE_PATH = r"E:\2ndstructuredata\raw data\D1_48_1.txt" # 48% ÏÜêÏÉÅ Îç∞Ïù¥ÌÑ∞
MODEL_PATH = r"E:\2ndstructuredata\Code\deeponet_phase2_structure_A.pth"
WINDOW_SIZE = 128
FS = 1000.0
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# --- Î™®Îç∏ ÌÅ¥ÎûòÏä§ (ÎèôÏùº) ---
class FourierFeature(nn.Module):
    def __init__(self, input_dim, mapping_size=256, scale=15):
        super().__init__()
        self.register_buffer('B', torch.randn(input_dim, mapping_size) * scale)
    def forward(self, x):
        projected = 2 * np.pi * (x @ self.B)
        return torch.cat([torch.sin(projected), torch.cos(projected)], dim=-1)

class DeepONetPhase2(nn.Module):
    def __init__(self, branch_dim, trunk_dim, hidden_dim=256, output_dim=256):
        super().__init__()
        self.activation = nn.SiLU()
        self.branch = nn.Sequential(
            nn.Linear(branch_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, output_dim),
        )
        self.fourier_dim = 256
        self.fourier = FourierFeature(trunk_dim, mapping_size=self.fourier_dim, scale=15.0)
        self.trunk = nn.Sequential(
            nn.Linear(self.fourier_dim * 2, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, hidden_dim), self.activation,
            nn.Linear(hidden_dim, output_dim),
        )
        self.bias = nn.Parameter(torch.zeros(1))
    def forward(self, u, y):
        B = self.branch(u)
        y_embedded = self.fourier(y)
        T = self.trunk(y_embedded)
        B_expanded = B.unsqueeze(1)
        return torch.sum(B_expanded * T, dim=-1) + self.bias

# --- Ìï®Ïàò Ï†ïÏùò ---
def load_data_robust(filepath):
    if not os.path.exists(filepath): return None
    y_data = []
    try:
        with open(filepath, 'r') as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) != 2: continue
                try: y_data.append(float(parts[1]))
                except ValueError: continue
        data = np.array(y_data, dtype=np.float32)
        reshaped = data.reshape(8, 200000).T
        return reshaped
    except Exception: return None

def calculate_di(healthy, damaged, fs=1000.0, window_sec=2.0):
    points = int(fs * window_sec)
    di_per_sensor = []
    for s in range(8):
        h_sig = healthy[:, s]
        d_sig = damaged[:, s]
        n_h = len(h_sig) // points
        n_d = len(d_sig) // points
        k_h = kurtosis(h_sig[:n_h*points].reshape(n_h, points), axis=1, fisher=False)
        k_d = kurtosis(d_sig[:n_d*points].reshape(n_d, points), axis=1, fisher=False)
        h_val = np.percentile(k_h, 95)
        d_val = np.percentile(k_d, 95)
        di_per_sensor.append(abs(h_val - d_val))
    return np.mean(di_per_sensor)

def main():
    print("[1] Loading Model...")
    model = DeepONetPhase2(branch_dim=1025, trunk_dim=2).to(device)
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device))
    model.eval()

    print("\n[2] Loading Data...")
    data_healthy = load_data_robust(HEALTHY_PATH)
    data_real_damage = load_data_robust(DAMAGE_PATH)
    if data_healthy is None or data_real_damage is None: return

    print("\n[3] Calculating Target DI...")
    target_di = calculate_di(data_healthy, data_real_damage)
    print(f"   üéØ Target DI: {target_di:.6f}")

    print("\n[4] Generating...")
    scaler = StandardScaler()
    data_healthy_scaled = scaler.fit_transform(data_healthy)
    data_real_scaled = scaler.transform(data_real_damage)
    
    n_samples = data_healthy.shape[0] // WINDOW_SIZE
    U_b = data_healthy_scaled[:n_samples*WINDOW_SIZE, :].reshape(n_samples, WINDOW_SIZE, 8)
    U_b_flat = U_b.reshape(n_samples, -1)
    
    di_col = np.full((n_samples, 1), target_di)
    U_combined = np.hstack([U_b_flat, di_col])
    
    t_idx = np.arange(WINDOW_SIZE)
    s_idx = np.arange(8)
    t_mesh, s_mesh = np.meshgrid(t_idx, s_idx, indexing='ij')
    y_grid = np.stack([t_mesh.flatten(), s_mesh.flatten()], axis=1)
    scaler_trunk = MinMaxScaler()
    y_grid_scaled = scaler_trunk.fit_transform(y_grid)
    y_batch_tensor = torch.FloatTensor(y_grid_scaled).unsqueeze(0).to(device)
    
    batch_size = 100
    generated_list = []
    with torch.no_grad():
        for i in range(0, n_samples, batch_size):
            u_batch = torch.FloatTensor(U_combined[i:i+batch_size]).to(device)
            curr_bs = u_batch.shape[0]
            y_batch = y_batch_tensor.repeat(curr_bs, 1, 1)
            pred = model(u_batch, y_batch)
            generated_list.append(pred.cpu().numpy())
    generated_data = np.concatenate(generated_list, axis=0)

    print("\n[5] Verifying Generated DI...")
    gen_reshaped = generated_data.reshape(n_samples, WINDOW_SIZE, 8).reshape(-1, 8)
    gen_phys_full = scaler.inverse_transform(gen_reshaped)
    generated_di = calculate_di(data_healthy, gen_phys_full)
    di_error = abs(target_di - generated_di) / target_di * 100
    print(f"   ü§ñ Generated DI: {generated_di:.6f}")
    print(f"   üìä DI Error: {di_error:.2f}%")

    # Metrics
    real_damage_flat = data_real_scaled[:n_samples*WINDOW_SIZE, :].reshape(n_samples, -1)
    mse = mean_squared_error(real_damage_flat, generated_data)
    corr, _ = pearsonr(real_damage_flat.flatten()[:10000], generated_data.flatten()[:10000])
    print(f"   MSE: {mse:.6f}, Corr: {corr:.4f}")

    # Plot
    sample_idx = 0
    real_phys = scaler.inverse_transform(real_damage_flat[sample_idx].reshape(128, 8))[:, 0]
    gen_phys = scaler.inverse_transform(generated_data[sample_idx].reshape(128, 8))[:, 0]
    
    plt.figure(figsize=(12, 6))
    plt.plot(real_phys, 'b-', label=f'Real (DI={target_di:.3f})')
    plt.plot(gen_phys, 'r--', label=f'Gen (DI={generated_di:.3f})')
    plt.title(f"Validation Structure B (DI Error: {di_error:.2f}%)")
    plt.legend()
    plt.savefig("structure_b_validation_DI_check.png")
    print("   Graph saved.")

if __name__ == "__main__":
    main()
